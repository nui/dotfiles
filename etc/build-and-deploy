#!/bin/zsh
set -e

readonly _SCRIPT_NAME=${0:t}

# Parse options {{{
usage() {
cat <<- EOU
Usage: $_SCRIPT_NAME [OPTIONS]

optional arguments:
  -b, --branch BRANCH   git branch
  -s, --stable          create bundle for upload to github release
  -h, --help            print this help message
EOU
}

getopt_options=(
    branch:
    help
    stable
)

if ! getopt_tmp=$(POSIXLY_CORRECT=true getopt -q -o b:hs --long ${(j:,:)getopt_options} -- "$@"); then
    # exit if error
    usage
    exit 1
fi

eval set -- $getopt_tmp
unset getopt_options
unset getopt_tmp

# Variables
declare _BRANCH
declare _STABLE

while true; do
    case $1 in
        -b | --branch ) _BRANCH=$2; shift 2 ;;
        -s | --stable ) _STABLE=true; shift ;;
        -h | --help ) usage; exit 0 ;;
        -- ) shift; break ;;
    esac
done
readonly _BRANCH
readonly _STABLE
# }}}

find_remote_branch() {
    local -a tmp_arr
    local remote_tracked=$(git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD))
    if [[ -z $remote_tracked ]]; then
        print -- "Can't find remote tracking branch"
        exit 1
    fi
    tmp_arr=(${(@s#/#)remote_tracked})
    # remote branch without remote name
    typeset -g find_remote_branch_result=${(@j#/#)tmp_arr[2,-1]}
}

set -x

readonly tmp_dir=$(mktemp -d --suffix=.bundle.nmk)
readonly cloud_object=gs://nuimk-nmk/nmk.tar.gz

readonly archive_name=nmk.tar.gz
readonly default_nmk_dir=.nmk
readonly git_dir=$tmp_dir/nmk
readonly staging_dir=$tmp_dir/staging

# Step 1. Clone from github
# -----------------------------------------------------------------------------
find_remote_branch
$NMK_DIR/setup/automate --branch ${_BRANCH:-$find_remote_branch_result} $git_dir


# Step 2. Generate files that need information from git
# -----------------------------------------------------------------------------
cd $git_dir
# don't run this on working environment
if [[ -e zsh/.zcompdump || -e zsh/.zsh_history || -d node_modules ]]; then
    >&2 echo "Aborted"
    exit 1
fi
() {
    set +x
    print -- "Built on $(date --rfc-3339=seconds)"
    print -- "\nBranch: $(git rev-parse --abbrev-ref HEAD)"
    print -- "\nLast 10 commits"
    git --no-pager log -n 10 --no-color --oneline --decorate --graph
    print -- "\nSubmodule:"
    git submodule
    print -- "\nVim plugins:"
    for repo (vim/bundle/*/) {
        cd $repo
        print -- "$(git rev-parse --verify HEAD)  ${repo:t}"
        cd -
    }
    set -x
} >> BUILD_INFO

# Step 3. Get rid of git and unnecessary files
# -----------------------------------------------------------------------------
mkdir $staging_dir
mkdir -m 700 $staging_dir/$default_nmk_dir
tar -c --exclude-vcs --exclude-from=$NMK_DIR/.bundleignore . | tar -x -C $staging_dir/$default_nmk_dir


# Step 4. Generate more files
# -----------------------------------------------------------------------------
cd $staging_dir/$default_nmk_dir
# add uninstaller script
cat > uninstall.sh << 'EOF'
#!/bin/sh
set -e
find . -name '*.pyc' -exec rm -f {} +
<.bundle-files xargs --null rm
EOF
# create a list of bundled files
find . ! -type d -print0 | sort --reverse --zero-terminated > .bundle-files
# unset write permission to get warning message on update read-only files
find . -type f -exec chmod ugo-w {} +
# set update script execute bit
chmod +x bin/nmk-update.py


# Step 5. Create final tar archive
# -----------------------------------------------------------------------------
cd $staging_dir
fakeroot tar -caf $tmp_dir/$archive_name --mtime="$(date)" $default_nmk_dir


# Step 6. Clean up and hash
# -----------------------------------------------------------------------------
cd $tmp_dir
# remove temporary directories
rm -rf $git_dir $staging_dir
# sha256 hash
sha256sum -b $archive_name > $archive_name.sha256

# Step 7. Upload to google cloud storage
gsutil -h "Cache-Control:private, max-age=0, no-transform" cp -a public-read $archive_name $cloud_object
gsutil -h "Cache-Control:private, max-age=0, no-transform" cp -a public-read $archive_name.sha256 $cloud_object.sha256

# Optional step for stable release
if [[ $_STABLE == true ]]; then
    gpg2 -b $archive_name
    print -- $tmp_dir
    if (( ${+commands[dolphin]} )); then
        dolphin $tmp_dir 2>/dev/null
    fi
fi
rm -rf $tmp_dir

