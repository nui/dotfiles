#!/bin/zsh
set -e

readonly _SCRIPT_NAME=${0:t}

# Parse options {{{
usage() {
cat <<- EOU
Usage: $_SCRIPT_NAME [OPTIONS]

optional arguments:
  -b, --branch BRANCH   git branch
  -k, --keep            do not delete temporary files
  -n, --no-upload       do not upload to cloud
  -s, --stable          create bundle for upload to github release
  -h, --help            print this help message
EOU
}

getopt_options=(
    branch:
    help
    keep
    no-upload
    stable
)

if ! getopt_tmp=$(POSIXLY_CORRECT=true getopt -q -o b:hkns --long ${(j:,:)getopt_options} -- "$@"); then
    # exit if error
    usage
    exit 1
fi

eval set -- $getopt_tmp
unset getopt_options
unset getopt_tmp

# Variables
declare _BRANCH
integer _KEEP=0
integer _STABLE=0
integer _UPLOAD=1

while true; do
    case $1 in
        -b | --branch ) _BRANCH=$2; shift 2 ;;
        -k | --keep ) _KEEP=1; shift ;;
        -n | --no-upload ) _UPLOAD=0; shift ;;
        -s | --stable ) _STABLE=1; shift ;;
        -h | --help ) usage; exit 0 ;;
        -- ) shift; break ;;
    esac
done
readonly _BRANCH
readonly _KEEP
readonly _STABLE
# }}}

find_remote_branch() {
    local -a tmp_arr
    local remote_tracked=$(git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD))
    if [[ -z $remote_tracked ]]; then
        print -- "Can't find remote tracking branch"
        exit 1
    fi
    tmp_arr=(${(@s#/#)remote_tracked})
    # remote branch without remote name
    typeset -g find_remote_branch_result=${(@j#/#)tmp_arr[2,-1]}
}

set -x

readonly archive_name='nmk.tar.gz'
readonly archive_prefix='.nmk'
readonly cloud_object=gs://nuimk-nmk/nmk.tar.gz
readonly script_git_root=${0:A:h:h}
readonly tmp_dir=$(mktemp -d --suffix=.nmk-build)

readonly archive_dir="$tmp_dir/$archive_prefix"
readonly assets_dir="$tmp_dir/assets"
readonly tmp_repo="$tmp_dir/nmk"

# Step 0. Change directory to git root of this script
cd $script_git_root

# Step 1. Clone from github
# -----------------------------------------------------------------------------
find_remote_branch
$script_git_root/setup/automate --branch ${_BRANCH:-$find_remote_branch_result} $tmp_repo


# Step 2. Generate files that need information from git
# -----------------------------------------------------------------------------
cd $tmp_repo
# don't run this on working environment
if [[ $script_git_root == $tmp_repo || -e zsh/.zcompdump || -e zsh/.zsh_history || -d node_modules ]]; then
    >&2 echo "Aborted"
    exit 1
fi
set +x
() {
    print -- "Built on $(date --rfc-3339=seconds)"
    print -- "\nBranch: $find_remote_branch_result"
    print -- "\nLast 10 commits"
    git --no-pager log -n 10 --no-color --oneline --decorate --graph
    print -- "\nSubmodule:"
    git submodule status
    print -- "\nVim plugins:"
    for repo (vim/bundle/*/) {
        pushd -q $repo
        print -- "$(git rev-parse --verify HEAD)  ${repo:t}"
        popd -q
    }
} >> .buildinfo
set -x

# Step 3. Get rid of git and unnecessary files
# -----------------------------------------------------------------------------
mkdir $archive_dir # don't remove this line, it should thrown error if $archive_dir = $tmp_repo
tar -c --exclude-vcs --exclude-from=$script_git_root/.archiveignore . | tar -x -C $archive_dir


# Step 4. Generate more files
# -----------------------------------------------------------------------------
cd $archive_dir
# add uninstaller script
cat > uninstall.sh << 'EOF'
#!/bin/sh
set -e
find . -name '*.pyc' -exec rm -f {} +
<.installed-files xargs --null rm
EOF
# create a list of bundled files
find . ! -type d -print0 | sort --reverse --zero-terminated > .installed-files
# unset write permission to get warning message on update read-only files
find . -type f -exec chmod ugo-w {} +
# set update script execute bit
chmod +x bin/nmk-update.py


# Step 5. Create final tar archive
# -----------------------------------------------------------------------------
mkdir $assets_dir
tar --owner=root:0 --group=root:0 --mtime="$(date)" \
    -C $tmp_dir \
    -caf $assets_dir/$archive_name $archive_prefix


# Step 7. hash and uploading
# -----------------------------------------------------------------------------
cd $assets_dir
# sha256 hash
sha256sum -b $archive_name > $archive_name.sha256

if (( $_UPLOAD )); then
    gsutil -h "Cache-Control:private, max-age=0, no-transform" cp -a public-read $archive_name $cloud_object
    gsutil -h "Cache-Control:private, max-age=0, no-transform" cp -a public-read $archive_name.sha256 $cloud_object.sha256
fi

# Step 7.1 (Stable only) Create gpg signature
if (( $_STABLE )); then
    gpg2 -b $archive_name
    if (( ${+commands[dolphin]} )); then
        dolphin $assets_dir 2>/dev/null
    else
        print -- $assets_dir
    fi
fi
# Step 8. remove temporary directories
if (( ! $_KEEP )); then
    rm -rf $tmp_dir
fi
