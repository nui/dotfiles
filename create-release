#!/bin/zsh
set -e

# Parse options {{{
usage() {
cat <<- EOU
Usage: create-release [OPTIONS]

Options
    -b, --branch BRANCH   git branch
    -s, --stable          create bundle for upload to github release
    -h, --help            print this help message
EOU
}

_OPTIONS=(
    branch:
    help
    stable
)

if ! _TEMP=$(POSIXLY_CORRECT=true getopt -q -o b:hs --long ${(j:,:)_OPTIONS} -- "$@"); then
    # exit if error
    usage
    exit 1
fi

eval set -- $_TEMP

# Variables
_BRANCH=
_STABLE=

while true; do
    case $1 in
        -b | --branch ) _BRANCH=$2; shift 2 ;;
        -s | --stable ) _STABLE=true; shift ;;
        -h | --help ) usage; exit 0 ;;
        -- ) shift; break ;;
    esac
done
# }}}

find_remote_branch() {
    local tracked
    local -a parts
    tracked=$(git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD))
    if [[ -z $tracked ]]; then
        print -- "Can't find remote tracking branch"
        exit 1
    fi
    parts=(${(@s#/#)tracked})
    # remote branch without remote name
    typeset -g find_remote_branch_result=${(@j#/#)parts[2,-1]}
}

set -x

tmp_dir=$(mktemp -d --suffix=.bundle.nmk)
cloud_object=gs://nuimk-nmk/nmk.tar.gz

archive_name=nmk.tar.gz
default_nmk_dir=.nmk
git_dir=$tmp_dir/nmk
staging_dir=$tmp_dir/staging

# Step 1. Clone from github
# -----------------------------------------------------------------------------
find_remote_branch
$NMK_DIR/setup/automate --branch ${_BRANCH:-$find_remote_branch_result} $git_dir


# Step 2. Generate files that need information from git
# -----------------------------------------------------------------------------
cd $git_dir
# don't run this on working environment
if [[ -e zsh/.zcompdump || -e zsh/.zsh_history || -d node_modules ]]; then
    >&2 echo "Aborted"
    exit 1
fi
date --rfc-3339=seconds > build-time
git log -n 10 --no-color --oneline --decorate --graph > last-10-commits


# Step 3. Get rid of git and unnecessary files
# -----------------------------------------------------------------------------
mkdir $staging_dir
mkdir -m 700 $staging_dir/$default_nmk_dir
tar -c --exclude-vcs --exclude-from=$NMK_DIR/.bundleignore . | tar -x -C $staging_dir/$default_nmk_dir


# Step 4. Generate more files
# -----------------------------------------------------------------------------
cd $staging_dir/$default_nmk_dir
# add uninstaller script
cat > uninstall.sh << 'EOF'
#!/bin/sh
set -e
find . -name '*.pyc' -exec rm -f {} +
<.bundle-files xargs --null rm
EOF
# create a list of bundled files
find . ! -type d -print0 | sort --reverse --zero-terminated > .bundle-files
# unset write permission to get warning message on update read-only files
find . -type f -exec chmod ugo-w {} +
# set update script execute bit
chmod +x bin/nmk-update.py


# Step 5. Create final tar archive
# -----------------------------------------------------------------------------
cd $staging_dir
tar -caf $tmp_dir/$archive_name --owner=0 --group=0 --mtime='' $default_nmk_dir


# Step 6. Clean up and hash
# -----------------------------------------------------------------------------
cd $tmp_dir
# remove temporary directories
rm -rf $git_dir $staging_dir
# sha256 hash
sha256sum -b $archive_name > $archive_name.sha256

# Step 7. Upload to google cloud storage
gsutil -h "Cache-Control:private, max-age=0, no-transform" cp -a public-read $archive_name $cloud_object
gsutil -h "Cache-Control:private, max-age=0, no-transform" cp -a public-read $archive_name.sha256 $cloud_object.sha256

# Optional step for stable release
if [[ $_STABLE == true ]]; then
    gpg2 -b $archive_name
    print -- $tmp_dir
    if (( ${+commands[dolphin]} )); then
        dolphin $tmp_dir 2>/dev/null
    fi
fi
rm -rf $tmp_dir

